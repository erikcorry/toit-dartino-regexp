// Copyright (C) 2022 Toitware ApS. All rights reserved.
// Use of this source code is governed by an MIT-style license that can be
// found in the third_party/toitware/LICENSE file.

import host.directory show *
import host.file
import reader show BufferedReader

// We don't have the Sputnik copyright message in plain text because automated
// tools might conclude that this file is under the Sputnik copyright.
SPUTNIK-COPYRIGHT ::= rot13 "// Pbclevtug 2009 gur Fchgavx nhgubef.  Nyy evtugf erfreirq."
SPUTNIK-COVERAGE  ::= rot13 "// Guvf pbqr vf tbirearq ol gur OFQ yvprafr sbhaq va gur YVPRAFR svyr."

SPUTNIK-DIR ::= "../../../../test262"

main:
  if not file.is-directory SPUTNIK-DIR:
    print "Expects to be run from the third_party/toitware/tools/directory."
    print "Expects test262 to be checked out next to the regexp checkout."
    exit 1
  license := file.read-content "$SPUTNIK-DIR/LICENSE"
  out := file.Stream.for-write "../../sputnik/LICENSE"
  out.write license

  out = file.Stream.for-write "../../sputnik/tests/sputnik_test.toit"
  out-unicode := file.Stream.for-write "../../sputnik/tests/sputnik_test_unicode.toit"
  out-deseret := file.Stream.for-write "../../sputnik/tests/sputnik_test_deseret.toit"
  [out, out-unicode, out-deseret].do:
    condense-tests-to-one-file it --unicode=(it != out) --deseret=(it == out-deseret)

condense-tests-to-one-file out --unicode/bool --deseret/bool -> none:
  out.write """
      $SPUTNIK-COPYRIGHT
      $SPUTNIK-COVERAGE

      // Autogenerated by make_sputnik_tests.toit

      import expect show *
      import regexp show RegExp
      import regexp

      check match expected:
        expect_equals match.capture_count (expected.size - 1)
        actual := []
        (match.capture_count + 1).repeat:
          actual.add match[it]
        if actual != expected:
          print "Expected\\n\$expected, got\\n\$actual"
        expect_equals expected actual

      main:
        re := null
        m := null
        expected := null
      """

  REGEXP-TESTS := "$SPUTNIK-DIR/test/built-ins/RegExp"
  dir := DirectoryStream REGEXP-TESTS
  emitted-entry := ""
  while entry := dir.next:
    if entry.starts-with "S" and entry.ends-with ".js":
      fd := file.Stream.for-read "$REGEXP-TESTS/$entry"
      try:
        emitted-regexp := false
        reader := BufferedReader fd
        if reader.read-line != SPUTNIK-COPYRIGHT: continue
        if reader.read-line != SPUTNIK-COVERAGE: continue
        while line := reader.read-line:
          index := line.index-of "__executed = "
          if index >= 0:
            emitted-regexp = handle-executed-line out entry line index --unicode=unicode --deseret=deseret
          index = line.index-of "__expected = "
          if index >= 0:
            if emitted-regexp:
              handle-expected-line out entry line index --unicode=unicode --deseret=deseret
          if emitted-regexp and line.starts-with "assert(!__executed":
            out.write "  expect_equals null m\n"
        finally:
          fd.close

is-alpha char/int -> bool:
  return 'a' <= char <= 'z'
      or 'A' <= char <= 'Z'

handle-executed-line out filename/string line/string index/int --unicode/bool --deseret/bool -> bool:
  if line[index + 13] != '/':
    out.write "\n"
    out.write "  // $filename\n"
    out.write "  // Rejected for not using literal regexp: $line\n"
    return false
  problem-for-unicode := false
  for dash-index := -2; dash-index != -1 and dash-index < line.size - 1; dash-index = line.index-of "-" (dash-index < 0 ? 0 : dash-index + 1):
    if dash-index > 0 and (is-alpha line[dash-index - 1]):
      problem-for-unicode = true
    if 0 <= dash-index < line.size - 1 and (is-alpha line[dash-index + 1]):
      problem-for-unicode = true
  // The regexp constructs \w and \b are inherently ASCII-only.
  if (line.index-of "\\w") >= 0 or (line.index-of "\\b") >= 0 or (line.index-of "\\B") >= 0:
    problem-for-unicode = true

  if unicode and problem-for-unicode:
    out.write "\n"
    out.write "  // $filename\n"
    out.write "  // Rejected for being ASCII-specific: $line\n"
    return false

  case-independent := false
  multi-line := false
  close := line[index + 14..].index-of "/."
  if close == -1:
    close = line[index + 14..].index-of "/i."
    if close != -1: case-independent = true
  if close == -1:
    close = line[index + 14..].index-of "/m."
    if close != -1: multi-line = true
  if close == -1:
    out.write "\n"
    out.write "  // $filename\n"
    out.write "  // Rejected for using /g flag: $line\n"
    return false
  method-index := (line[index + 14 + close..].index-of ".")
  if method-index == -1: throw "Could not parse $line"
  method-index += index + 15 + close
  method := null
  if line[method-index..].starts-with "exec(":
    method = "exec"
  else if line[method-index..].starts-with "test(":
    method = "test"
  else:
    throw "Could not parse $line $line[method-index..]"
  re-text := line[index + 14..index + 14 + close]
  escaped := convert-from-js-regexp-to-toit-escape re-text --unicode-munge=unicode --deseret-munge=deseret
  out.write "\n"
  out.write "  // $filename\n"
  out.write "  re = RegExp \"$escaped\" --case_sensitive=$(not case-independent) --multiline=$multi-line\n"
  input-quote := line[method-index + 5]
  if input-quote != '"' and input-quote != '\'':
    out.write "  // Rejected input ($line[method-index + 5..]\n"
    return false
  end-quote := line[method-index + 6..].index-of --last "$(%c input-quote)"
  if end-quote == -1: throw "Where is the end: $line"
  input := line[method-index + 6..method-index + 6 + end-quote]
  input = convert-from-js-string-to-toit-escape input --unicode-munge=unicode --deseret-munge=deseret
  out.write "  m = re.first_matching \"$input\"\n"
  return true

handle-expected-line out filename/string line/string index/int --unicode/bool --deseret/bool -> none:
  if line[index + 13] != '[':
    out.write "  // Rejected test: '$line'\n"
    return
  end-index := line.index-of --last "]"
  array-contents := line[index + 14..end-index]
  expected := escape-js-array array-contents --unicode-munge=unicode --deseret-munge=deseret
  if expected:
    out.write "  expected = $expected\n"
    out.write "  check m expected\n"
  else:
    out.write "  // Rejected for containing non-literal expectation $line\n"

convert-from-js-regexp-to-toit-escape str/string --unicode-munge/bool=false --deseret-munge=false -> string:
  str = parse-js-regexp str
  str = toit-escape str --unicode-munge=unicode-munge --deseret-munge=deseret-munge
  return str

convert-from-js-string-to-toit-escape str/string --unicode-munge/bool=false --deseret-munge=false -> string:
  str = parse-js-string str
  str = toit-escape str --unicode-munge=unicode-munge --deseret-munge=deseret-munge
  return str

MUST-ESCAPE-TOIT ::= ByteArray 128:
  esc := it == '$' or it == '\\' or it == '"' or it == '\n' or it == '\t'
  hex := it < 32 or it == 127
  esc ? 2 : (hex ? 4 : 1)

must-escape-toit char/int? -> int:
  if not char:
    return 0  // Not at the start of a character in the string.
  if char >= MUST-ESCAPE-TOIT.size:
    if char >= 0x10000:
      return 10  // \u{012345}
    else:
      return 6   // \u1234
  else:
    return MUST-ESCAPE-TOIT[char]

MUNGE-MAP ::= {
    'a': "å",
    'c': "ç",
    'e': "é",
    'g': "ġ",
    'i': "ï",
    'l': "ł",
    'o': "ø",
    'u': "ü",
    'A': "Å",
    'C': "Ç",
    'E': "É",
    'G': "Ġ",
    'I': "Ï",
    'L': "Ł",
    'O': "Ø",
    'U': "Ü",
}

MUNGE-MAP-DESERET ::= {
    'a': "𐐰",
    'b': "𐐺",
    'c': "𐑅",
    'e': "é",
    'g': "𐑀",
    'i': "𐐮",
    'l': "𐑊",
    'o': "𐐲",
    'u': "𐐭",
    'A': "𐐈",
    'B': "𐐒",
    'C': "𐐝",
    'E': "É",
    'G': "𐐘",
    'I': "𐐆",
    'L': "𐐢",
    'O': "𐐊",
    'U': "𐐅",
}

/// Escapes a string so that it can be used in Toit source code.
toit-escape str/string --unicode-munge/bool=false --deseret-munge/bool=false -> string:
  MAP ::= deseret-munge ? MUNGE-MAP-DESERET : MUNGE-MAP
  double-quote-found := false
  str.do:
    if it == '"' and (str.index-of "\"\"\"") == -1:
      double-quote-found = true
      continue.do
    if (unicode-munge and MAP.contains it) or (must-escape-toit it) != 1:
      out-bytes := 0
      str.do:
        if unicode-munge and MAP.contains it:
          out-bytes += MAP[it].size
        else:
          out-bytes += must-escape-toit it
      ba := ByteArray out-bytes
      i := 0
      str.do: | char/int? |
        bytes := ?
        if unicode-munge and MAP.contains char:
          bytes = MAP[char].size
          replacement := MAP[char]
          ba.replace i replacement
          i += replacement.size
          continue.do
        bytes = must-escape-toit char
        if bytes == 1:
          ba[i++] = char
        else if bytes == 2:
          ba[i++] = '\\'
          ba[i++] = char == '\n' ? 'n' : char == '\t' ? 't' : char
        else if bytes == 4:
          ba[i++] = '\\'
          ba[i++] = 'x'
          ba[i++] = to-lower-case-hex (char >> 4) & 0xf
          ba[i++] = to-lower-case-hex (char & 0xf)
        else if bytes >= 6:
          ba[i++] = '\\'
          ba[i++] = 'u'
          if bytes == 10:
            ba[i++] = '{'
            ba[i++] = to-lower-case-hex (char >> 20) & 0xf
            ba[i++] = to-lower-case-hex (char >> 16) & 0xf
          ba[i++] = to-lower-case-hex (char >> 12) & 0xf
          ba[i++] = to-lower-case-hex (char >> 8) & 0xf
          ba[i++] = to-lower-case-hex (char >> 4) & 0xf
          ba[i++] = to-lower-case-hex (char & 0xf)
          if bytes == 10: ba[i++] = '}'
        else:
          assert: bytes == 0
      return ba.to-string
  if double-quote-found:
    return "\"\"$str\"\""
  return str

/**
Reads a regexp expressed in JS source and returns the string that will be
  passed to the regexp engine.  Most chars are passed unchanged.
*/
parse-js-regexp str -> string:
  l := []
  for i := 0; i < str.size; i++:
    char := str[i]
    if not char: continue
    if char == '\\':
      // A JS regexp can't end with an unescaped backslash so this should never
      // fail.
      next := str[i + 1]
      if next == '/':
        l.add '/'  // backslash-forward-slash becomes a single forward slash.
      else if next == '\\':
        l.add '\\'  // double backslash becomes a quad backslash.
        l.add '\\'
      else:
        l.add '\\'
        l.add next
      i++
    else:
      l.add char
  return string.from-runes l

JS-STRING-ESCAPES_ ::= {
  '\'': '\'',
  '"':  '"',
  '\\': '\\',
  'n':  '\n',
  'r':  '\r',
  't':  '\t',
  'b':  '\b',
  'f':  '\f',
  'v':  '\v',
}

/**
Reads a string expressed in JS source and returns the string that will be
  generated by the compiler.
*/
parse-js-string str -> string:
  l := []
  for i := 0; i < str.size; i++:
    char := str[i]
    if not char: continue
    if char == '"':
      l.add '"'
    else if char == '\'':
      l.add '\''
    else if char == '\\':
      // A JS source string can't end with an unescaped backslash so this
      // should never fail.
      next := str[i + 1]
      if JS-STRING-ESCAPES_.contains next:
        l.add JS-STRING-ESCAPES_[next]
      else if next == 'x':  // \xa2.
        c := (hex-char-to-value str[i + 2]) << 4
        c |= (hex-char-to-value str[i + 3])
        l.add c
        i += 2
      else if next == 'u':  // \u12a5.
        c := (hex-char-to-value str[i + 2]) << 12
        c |= (hex-char-to-value str[i + 3]) << 8
        c |= (hex-char-to-value str[i + 4]) << 4
        c |= (hex-char-to-value str[i + 5])
        l.add c
        i += 4
      else if next == '0':  // Octal escape.
        c := 0
        j := 1
        while j <= 3:
          if not str[i + j]:
            break
          if not '0' <= str[i + j] <= '9':
            break
          c <<= 3
          c += str[i + j] - '0'
          j++
        l.add c
        i += j - 1
      else:  // Random letter escaped for no reason, eg \a.
        l.add next
      i++
    else:
      l.add char
  return string.from-runes l

escape-js-array input/string --unicode-munge/bool=false --deseret-munge/bool=false -> List?:
  result := []
  for i := 0; i < input.size; i++:
    if input[i] == ' ': continue
    if input[i..].starts-with "undefined":
      result.add null
      i += 9
    else if input[i..].starts-with "__body,":
      return null
    else if input[i..] == "__strOriginal":
      return null
    else if input[i] == '\'' or input[i] == '"':
      i++
      start := i
      while i < input.size and input[i] != input[start - 1]:
        if input[i] == '\\': i++
        i++
      end := i
      i++
      converted := convert-from-js-string-to-toit-escape
          input[start..end]
          --unicode-munge=unicode-munge
          --deseret-munge=deseret-munge
      result.add "\"$converted\""
    else:
      throw "Lost in $input at $i $(%c input[i])"
    while i < input.size and input[i] == ' ': i++
    if i < input.size:
      if input[i] != ',':
        throw "Lost in $input at $i"
  return result

rot13 str -> string:
  ba := ByteArray str.size:
    c := str[it]
    if 'a' <= c <= 'm':
      c + 13
    else if 'n' <= c <= 'z':
      c - 13
    else if 'A' <= c <= 'M':
      c + 13
    else if 'N' <= c <= 'Z':
      c - 13
    else:
      c
  return ba.to-string
