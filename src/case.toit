// Copyright (c) 2015, the Dartino project authors. Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE.md file.

part of dart.core_patch;

ToUpperConverter toUpper;
ToLowerConverter toLower;
RegExpCanonicalizer regExpCanonicalize;
RegExpEquivalenceClasses regExpEquivalenceClasses;

// This is a case conversion library.  It is based on the idea of running a
// little program written in a bytecode.  The program makes calls to a user-
// supplied function, passing two integer Unicode codepoints as arguments.  The
// mapping (to upper case or to lower case) is defined by these code point
// pairs.

// While this is a very compact way to represent case mapping, it is not
// so convenient for actually converting strings to upper case or lower case.
// In order to do this we first observe that most texts are written in one
// language or very few languages.  Secondly, the characters used by a given
// language are grouped together in blocks, which always start on a codepoint
// that is divisible by 16.  See https://en.wikipedia.org/wiki/Unicode_block
// It follows that most texts access a limited number of blocks.

// We group the Unicode codepoint space into groups of 256, starting at a code
// point divisible by 256, which we call pages.  We use the bytecode programs
// to generate 256-entry sparse arrays on demand.  As an optimization, since
// each program generates mappings in strictly ascending order, we can stop
// running the program when the first codepoint appears that is above the page
// we are currently interested in.

// For toUpperCase and toLowerCase, the maps of the code point pages are simply
// lists of 256 strings, containing the 1-character string that is the mapping
// for the corresponding character (or rarely 2 or 3 characters).  Most Unicode
// characters do not have any case mapping (only about 1100 out of 29
// thousand), and we do not want to store lots of short strings for characters
// that are unchanged by case mapping, so a null represents "no change", and a
// null instead of an array provides a compact representation of a page where
// all characters map to themselves.

// For case canonicalization in JS-compatible regexps we only use the single-
// character upper case mappings.  In this case we use integer code points
// instead of strings in the page lists.  We also generate equivalence classes
// for use in regular expression []-style character classes.  These are in the
// form of small integer lists, where null represents the single entry
// equivalence class with just the original character in it.

const pageShift = 8;
const pageSize = 1 << pageShift;
const pageMask = pageSize - 1;

String toSomeCase(CaseConverter<String> converter, String src) {
  if (src.isEmpty) return src;
  StringBuffer b = new StringBuffer();
  int index = 0;
  int substringStart = -1;

  void flushSubstring() {
    if (substringStart != -1) {
      b.write(src.substring(substringStart, index));
      substringStart = -1;
    }
  }

  for (int code in src.runes) {
    String dest = converter.map(code);
    if (dest == null) {
      if (substringStart == -1) substringStart = index;
    } else {
      flushSubstring();
      b.write(dest);
    }
    index++;
    if (code >= 0x10000) index++;  // Surrogate pairs!
  }
  if (substringStart == 0) return src;
  flushSubstring();
  return b.toString();
}

String internalToUpperCase(String src) {
  if (toUpper == null) toUpper = new ToUpperConverter();
  return toSomeCase(toUpper, src);
}

String internalToLowerCase(String src) {
  if (toLower == null) toLower = new ToLowerConverter();
  return toSomeCase(toLower, src);
}

List<int> internalRegExpEquivalenceClass(int charCode) {
  if (regExpEquivalenceClasses == null) {
    regExpEquivalenceClasses = new RegExpEquivalenceClasses();
  }
  return regExpEquivalenceClasses.map(charCode);
}

int internalRegExpCanonicalize(int codeUnit) {
  if (regExpCanonicalize == null) {
    regExpCanonicalize = new RegExpCanonicalizer();
  }
  int answer = regExpCanonicalize.map(codeUnit);
  if (answer == null) return codeUnit;  // Unchanged.
  return answer;
}

abstract class CaseTable<T> {
  Map <int, List<T>> _pages = new Map <int, List<T>>();
  int _lastPageNumber = -1;
  List<T> _lastPageMap;

  List<T> _addPage(int page);

  T map(int charCode) {
    int page = charCode >> pageShift;
    if (page != _lastPageNumber) {
      if (!_pages.containsKey(page)) _pages[page] = _addPage(page);
      _lastPageNumber = page;
      _lastPageMap = _pages[page];
    }
    return _lastPageMap == null ? null : _lastPageMap[charCode & pageMask];
  }
}

abstract class CaseConverter<T> extends CaseTable<T> {
  void _run(bool f(int from, int to, bool append));

  void addEntry(List<T> pageList, int from, int to, bool append);

  List<T> _addPage(int page) {
    int min = page << pageShift;
    int max = min + pageMask;
    List<T> pageList;
    bool f(int from, int to, bool append) {
      if (from > max) return false;  // Stop now.
      if (from >= min) {
        if (pageList == null) pageList = new List<T>(pageSize);
        addEntry(pageList, from, to, append);
      }
      return true;  // Continue.
    }
    _run(f);
    // May be null, meaning none of the characters on this page are mapped to
    // different characters.
    return pageList;
  }
}

abstract class StringCaseConverter extends CaseConverter<String> {
  void addEntry(List<String> pageList, int from, int to, bool append) {
    String toString = new String.fromCharCode(to);
    int lowBits = (from & pageMask);
    if (append && pageList[lowBits] != null) {
      // This is relatively rare, and the string never ends up larger than
      // 3 characters.
      pageList[lowBits] += toString;
    } else {
      pageList[lowBits] = toString;
    }
  }
}

// Regular expression canonicalization uses the to-upper tables, but is specced
// to only use the single character mappings.  We use char codes, not short
// strings.
class RegExpCanonicalizer extends CaseConverter<int> {
  void addEntry(List<int> pageList, int from, int to, bool append) {
    int lowBits = (from & pageMask);
    pageList[lowBits] = to;
  }

  void _run(bool f(int from, int to, bool append)) {
    final doMap =
        (int from, int to) => f(from, to, false);  // Unused boolean argument.
    new Interpreter(toUpperProgram, true).interpret(doMap);
  }
}

// toUpperCase maps from char codes to short strings (1-3 characters).
class ToUpperConverter extends StringCaseConverter {
  void _run(bool f(int from, int to, bool append)) {
    final overwriteMap = (int from, int to) => f(from, to, false);
    final appendMap = (int from, int to) => f(from, to, true);

    // Single character upper case mappings.
    new Interpreter(toUpperProgram, true).interpret(overwriteMap);
    // First character of multi-character upper case mappings.
    new Interpreter(s1Program, true).interpret(overwriteMap);
    // Second character of multi-character upper case mappings.
    new Interpreter(s2Program, true).interpret(appendMap);
    // Third character of multi-character upper case mappings.
    new Interpreter(s3Program, true).interpret(appendMap);
  }
}

// toLowerCase maps from char codes to one-character strings.
class ToLowerConverter extends StringCaseConverter {
  void _run(bool f(int from, int to, bool append)) {
    final overwriteMap = (int from, int to) => f(from, to, false);
    new Interpreter(toLowerProgram, false).interpret(overwriteMap);
  }
}

// The equivalence classes map from char codes to short lists of
// equivalent char codes.
class RegExpEquivalenceClasses extends CaseTable<List<int>> {
  static const lastAsciiCharCode = 0x7f;

  List<List<int>> _addPage(int page) {
    int min = page << pageShift;
    int max = min + pageMask;
    // This will be the result from this method, a list of char codes for each
    // input char code, which the input char code is equivalent to.
    List<List<int>> pageList = new List<List<int>>(pageSize);

    // Temporary working map, that is discarded after this method returns.
    Map<int, List<int>> charsThatMapToEachCanonical = new Map<int, List<int>>();

    // For the first run of the case interpreter, this collects the upper case
    // characters that this block of characters map to.
    bool collectCanonicals(int from, int to) {
      if (from > max) return false;  // Stop now.
      // Due to a strange rule in 21.2.2.8.2 step 3g we ignore mappings from
      // ASCII to non-ASCII.
      if (from >= min &&
          (to > lastAsciiCharCode || from <= lastAsciiCharCode)) {
        if (pageList == null) pageList = new List<List<int>>(pageSize);
        charsThatMapToEachCanonical.putIfAbsent(to, () => new List<int>());
        pageList[from & pageMask] = charsThatMapToEachCanonical[to];
      }
      return true;  // Continue.
    }

    // Get single character upper case mappings.
    new Interpreter(toUpperProgram, true).interpret(collectCanonicals);

    if (pageList == null) return null;

    // For those characters that are not mentioned by the interpreter, this
    // means they map to themselves.  Add single-entry lists to the page to
    // reflect that.
    for (int code = min; code <= max; code++) {
      if (pageList[code & pageMask] == null) {
        pageList[code & pageMask] =
            charsThatMapToEachCanonical.putIfAbsent(code, () => new List<int>())
              ..add(code);
      }
    }
    for (int canonical in charsThatMapToEachCanonical.keys) {
      List<int> equivalenceClass = charsThatMapToEachCanonical[canonical];
      // If the canonical upper case character is not in the from-to range it
      // will not yet have been added to its own equivalence class.  Fix that.
      // It's OK to do "contains" on this list because they are never longer
      // than 4 elements.
      if (!equivalenceClass.contains(canonical)) {
        equivalenceClass.add(canonical);
      }
    }

    // For the second run of the case interpreter this collects all the
    // characters that map to one of the upper case forms we are interested in.
    bool collectSets(int from, int to) {
      if ((to > lastAsciiCharCode || from <= lastAsciiCharCode) &&
          charsThatMapToEachCanonical.containsKey(to)) {
        charsThatMapToEachCanonical[to].add(from);
      }
      // Always continue, we have to run through all the toUpperCase byte codes.
      return true;
    }

    new Interpreter(toUpperProgram, true).interpret(collectSets);

    bool atLeastOneMapping = false;

    for (int i = 0; i < pageSize; i++) {
      if (pageList[i].length == 1) {
        pageList[i] = null;
      } else {
        atLeastOneMapping = true;
      }
    }

    if (!atLeastOneMapping) return null;

    return pageList;
  }
}

// These are bytecodes for the little interpreter below.  See the block
// of comments at the top of this file and above the interpreter for
// explanation.  Generated from the Unicode standard in 2014.  See
// tools/generate_case_tables.dart'
// TODO: This is fairly compact in the snapshot, but not so compact at run
// time. We should have a compact way to represent byte data at runtime.
const List<int> toUpperProgram = const
    [0x01, 0xa1, 0x1a, 0x45, 0xba, 0x0e, 0xdc, 0x62, 0xaa, 0x16, 0x45, 0x4d,
     0x07, 0x45, 0x05, 0xf8, 0x6a, 0x18, 0x48, 0x01, 0xc9, 0x6a, 0x48, 0x48,
     0x50, 0x07, 0x48, 0x50, 0x16, 0x48, 0x50, 0x48, 0x48, 0x40, 0x01, 0xd3,
     0x62, 0x09, 0xc3, 0x72, 0x48, 0x50, 0x58, 0x58, 0x82, 0x50, 0x07, 0xf6,
     0x7a, 0x40, 0x08, 0xfd, 0x7a, 0x08, 0xe0, 0x72, 0x48, 0x48, 0x50, 0x50,
     0x82, 0x50, 0x58, 0x48, 0x50, 0x58, 0x48, 0x07, 0xf7, 0x6a, 0x84, 0x40,
     0x49, 0x40, 0x49, 0x40, 0x49, 0x07, 0x48, 0x40, 0x06, 0xce, 0x6a, 0x08,
     0x48, 0x50, 0x40, 0x49, 0x58, 0x13, 0x48, 0x58, 0x09, 0x48, 0x87, 0x50,
     0x02, 0x31, 0xfd, 0x63, 0x6b, 0x48, 0x83, 0x04, 0x48, 0x40, 0x02, 0x31,
     0xf1, 0x60, 0x60, 0x65, 0x05, 0xfc, 0x67, 0x6f, 0x65, 0x6b, 0x6f, 0x63,
     0x0a, 0x1e, 0xeb, 0x7a, 0x06, 0xd3, 0x62, 0x0a, 0x1e, 0xec, 0x6a, 0x06,
     0xd4, 0x6a, 0x0a, 0x1e, 0xcd, 0x62, 0x0a, 0x1e, 0xea, 0x6a, 0x06, 0xd8,
     0x61, 0x69, 0x02, 0x31, 0xe2, 0x62, 0x0a, 0x1e, 0xed, 0x72, 0x06, 0xdc,
     0x6a, 0x02, 0x31, 0xee, 0x62, 0x06, 0xdb, 0x74, 0x74, 0x85, 0x02, 0x31,
     0xe4, 0x72, 0x06, 0xe3, 0x75, 0x7d, 0x0a, 0x1e, 0xf1, 0x62, 0x06, 0xee,
     0x62, 0x09, 0xc4, 0x62, 0x06, 0xf0, 0x63, 0x63, 0x09, 0xc5, 0x62, 0x85,
     0x06, 0xf7, 0x62, 0x8a, 0x0a, 0x1e, 0xf4, 0x60, 0x60, 0x02, 0xa6, 0x0e,
     0xd9, 0x62, 0xab, 0x48, 0x58, 0x58, 0x0f, 0xfc, 0x03, 0x63, 0xae, 0x0e,
     0xc4, 0x64, 0x64, 0x63, 0x6b, 0x11, 0x45, 0x0e, 0xe3, 0x62, 0x09, 0x45,
     0x0e, 0xca, 0x64, 0x64, 0x6b, 0x65, 0x0e, 0xd8, 0x7a, 0x0e, 0xe6, 0x62,
     0x0e, 0xe0, 0x62, 0x4a, 0x0b, 0x48, 0x40, 0x0e, 0xda, 0x62, 0x47, 0x0f,
     0xf9, 0x62, 0x0d, 0xff, 0x6a, 0x0e, 0xd5, 0x72, 0x50, 0x50, 0xb2, 0x20,
     0x45, 0x0f, 0x47, 0x4f, 0x11, 0x48, 0x88, 0x1a, 0x48, 0x50, 0x06, 0x48,
     0x40, 0x13, 0xc0, 0x6a, 0x30, 0x48, 0xb0, 0x26, 0x46, 0x39, 0xb1, 0x06,
     0x42, 0x25, 0xbb, 0x0a, 0x1d, 0xfd, 0x7a, 0x02, 0x31, 0xe3, 0x7a, 0x02,
     0x80, 0x01, 0x0b, 0x48, 0x84, 0x01, 0x39, 0xe0, 0x6a, 0x84, 0x2f, 0x48,
     0x40, 0x01, 0x3c, 0xc7, 0x08, 0x63, 0x88, 0x01, 0x3c, 0xd7, 0x06, 0x63,
     0x8a, 0x01, 0x3c, 0xe7, 0x08, 0x63, 0x88, 0x01, 0x3c, 0xf7, 0x08, 0x63,
     0x88, 0x01, 0x3d, 0xc7, 0x06, 0x63, 0x8b, 0x01, 0x3d, 0xd7, 0x04, 0x6c,
     0x87, 0x01, 0x3d, 0xe7, 0x08, 0x63, 0x88, 0x01, 0x3e, 0xf9, 0x63, 0x63,
     0x01, 0x3f, 0xc7, 0x04, 0x63, 0x01, 0x3f, 0xd9, 0x63, 0x63, 0x01, 0x3f,
     0xf7, 0x63, 0x63, 0x01, 0x3f, 0xe9, 0x63, 0x63, 0x01, 0x3f, 0xf9, 0x63,
     0x73, 0x01, 0x3e, 0xc7, 0x08, 0x63, 0x88, 0x01, 0x3e, 0xd7, 0x08, 0x63,
     0x88, 0x01, 0x3e, 0xe7, 0x08, 0x63, 0x88, 0x01, 0x3e, 0xf7, 0x63, 0x6b,
     0x6d, 0x89, 0x0e, 0xd9, 0x6a, 0x83, 0x01, 0x3f, 0xcc, 0x6a, 0x8b, 0x01,
     0x3f, 0xd7, 0x63, 0x63, 0x8e, 0x01, 0x3f, 0xe7, 0x63, 0x7b, 0x7d, 0x8a,
     0x01, 0x3f, 0xfc, 0x7a, 0x05, 0x97, 0x02, 0x04, 0xf2, 0x7a, 0x9e, 0x10,
     0x43, 0x84, 0x40, 0x0d, 0x8b, 0x1a, 0x44, 0x1d, 0x86, 0x2e, 0x46, 0x56,
     0x58, 0x08, 0xf6, 0x66, 0x6e, 0x03, 0x48, 0x85, 0x50, 0x50, 0x88, 0x32,
     0x48, 0x87, 0x48, 0x48, 0x83, 0x48, 0x8b, 0x01, 0x02, 0xdf, 0x25, 0x63,
     0x6b, 0x6c, 0x84, 0x01, 0x03, 0xcd, 0x6a, 0x07, 0x24, 0x92, 0x17, 0x48,
     0x92, 0x0e, 0x48, 0x02, 0x86, 0x06, 0x48, 0x58, 0x1f, 0x48, 0x89, 0x48,
     0x50, 0x05, 0x48, 0x83, 0x48, 0x83, 0x48, 0x58, 0x0a, 0x48, 0x8a, 0x48,
     0x48, 0x0e, 0x9a, 0x0a, 0x1e, 0xf3, 0x6a, 0x9b, 0x01, 0x0e, 0xdf, 0x01,
     0x10, 0x63, 0x05, 0x0e, 0x81, 0x1a, 0x45, 0x13, 0x8d, 0x10, 0x0f, 0xff,
     0x28, 0x63, 0x21, 0xb0, 0x10, 0x31, 0xff, 0x33, 0x63, 0x2f, 0x8d, 0x20,
     0x45];

const List<int> s1Program = const
    [0x03, 0x9f, 0x01, 0xd3, 0x62, 0x01, 0x90, 0x04, 0xf0, 0x62, 0x98, 0x0a,
     0xfc, 0x62, 0x02, 0xa6, 0x01, 0xca, 0x62, 0x06, 0x9f, 0x0e, 0xd9, 0x62,
     0x9f, 0x0e, 0xe5, 0x62, 0x07, 0x96, 0x14, 0xf5, 0x62, 0x01, 0x24, 0x8e,
     0x01, 0xc8, 0x62, 0x01, 0xd1, 0x65, 0x65, 0x64, 0x01, 0xc1, 0x62, 0x02,
     0xb5, 0x0e, 0xe5, 0x04, 0x6a, 0xa8, 0x01, 0x3c, 0xc7, 0x08, 0x63, 0x01,
     0x3c, 0xc7, 0x08, 0x63, 0x01, 0x3c, 0xe7, 0x08, 0x63, 0x01, 0x3c, 0xe7,
     0x08, 0x63, 0x01, 0x3d, 0xe7, 0x08, 0x63, 0x01, 0x3d, 0xe7, 0x07, 0x63,
     0x73, 0x01, 0x3e, 0xfa, 0x62, 0x0e, 0xd1, 0x62, 0x0e, 0xc6, 0x6a, 0x0e,
     0xd1, 0x62, 0x62, 0x84, 0x62, 0x85, 0x01, 0x3f, 0xca, 0x62, 0x0e, 0xd7,
     0x62, 0x0e, 0xc9, 0x6a, 0x0e, 0xd7, 0x62, 0x62, 0x84, 0x62, 0x85, 0x64,
     0x72, 0x62, 0x62, 0x8a, 0x0e, 0xe5, 0x62, 0x62, 0x0e, 0xdd, 0x6e, 0x66,
     0x62, 0x8a, 0x01, 0x3f, 0xfa, 0x62, 0x0e, 0xe9, 0x62, 0x0e, 0xcf, 0x6a,
     0x0e, 0xe9, 0x62, 0x62, 0x84, 0x62, 0x0d, 0x2c, 0x83, 0x01, 0xc6, 0x05,
     0x62, 0x01, 0xd3, 0x62, 0x62, 0x8c, 0x15, 0xc4, 0x03, 0x62, 0x15, 0xce,
     0x62, 0x15, 0xc4, 0x62];

const List<int> s2Program = const
    [0x03, 0x9f, 0x01, 0xd3, 0x62, 0x01, 0xa9, 0x01, 0xce, 0x62, 0x02, 0xa6,
     0x0c, 0xcc, 0x62, 0x06, 0x9f, 0x0c, 0xc8, 0x62, 0x9f, 0x62, 0x07, 0x96,
     0x15, 0xd2, 0x62, 0x01, 0x24, 0x8e, 0x0c, 0xf1, 0x62, 0x0c, 0xc6, 0x64,
     0x64, 0x62, 0x0a, 0xfe, 0x62, 0x02, 0xb5, 0x0c, 0xd3, 0x04, 0x6a, 0xa8,
     0x0e, 0xd9, 0x2f, 0x62, 0x72, 0x62, 0x62, 0x6a, 0x0d, 0xc2, 0x62, 0x62,
     0x84, 0x0e, 0xd9, 0x62, 0x85, 0x62, 0x62, 0x6a, 0x0d, 0xc2, 0x62, 0x62,
     0x84, 0x0e, 0xd9, 0x62, 0x85, 0x0c, 0xc8, 0x62, 0x72, 0x0d, 0xc2, 0x62,
     0x0c, 0xc8, 0x62, 0x8a, 0x62, 0x62, 0x0c, 0xd3, 0x6a, 0x0d, 0xc2, 0x62,
     0x0c, 0xc8, 0x62, 0x8a, 0x0e, 0xd9, 0x62, 0x62, 0x6a, 0x0d, 0xc2, 0x62,
     0x62, 0x84, 0x0e, 0xd9, 0x62, 0x0d, 0x2c, 0x83, 0x01, 0xc3, 0x03, 0x65,
     0x01, 0xc6, 0x62, 0x62, 0x01, 0xd4, 0x62, 0x62, 0x8c, 0x15, 0xc6, 0x62,
     0x14, 0xf5, 0x62, 0x14, 0xfb, 0x62, 0x15, 0xc6, 0x62, 0x14, 0xfd, 0x62
     ];

const List<int> s3Program = const
    [0x0e, 0x90, 0x0c, 0xc1, 0x62, 0x9f, 0x62, 0x01, 0x2e, 0xa1, 0x69, 0x6b,
     0x0d, 0xc2, 0x6a, 0x01, 0x9f, 0x0e, 0xd9, 0x6a, 0x8e, 0x6a, 0x89, 0x0b,
     0xff, 0x63, 0x7b, 0x0d, 0xc2, 0x7a, 0x87, 0x0b, 0xff, 0x63, 0x7b, 0x0d,
     0xc2, 0x7a, 0x8c, 0x0e, 0xd9, 0x7a, 0x0d, 0x2c, 0x88, 0x01, 0xc6, 0x65,
     0x65];

const List<int> toLowerProgram = const
    [0x01, 0x81, 0x1a, 0x45, 0x01, 0xa5, 0x16, 0x45, 0x4d, 0x07, 0x45, 0xa1,
     0x18, 0x48, 0x01, 0xe9, 0x6a, 0x48, 0x48, 0x50, 0x07, 0x48, 0x50, 0x17,
     0x48, 0x03, 0xff, 0x62, 0x48, 0x48, 0x58, 0x09, 0xd3, 0x62, 0x48, 0x48,
     0x63, 0x48, 0x64, 0x63, 0x50, 0x07, 0xdd, 0x62, 0x09, 0xd7, 0x64, 0x64,
     0x48, 0x67, 0x6d, 0x09, 0xea, 0x61, 0x61, 0x58, 0x09, 0xec, 0x65, 0x6d,
     0x65, 0x03, 0x48, 0x0a, 0xc0, 0x62, 0x48, 0x75, 0x48, 0x67, 0x48, 0x64,
     0x63, 0x48, 0x48, 0x0a, 0xd2, 0x62, 0x58, 0x58, 0x84, 0x41, 0x48, 0x41,
     0x48, 0x41, 0x08, 0x48, 0x50, 0x08, 0x48, 0x50, 0x41, 0x48, 0x48, 0x06,
     0xd5, 0x62, 0x06, 0xff, 0x62, 0x14, 0x48, 0x06, 0xde, 0x6a, 0x09, 0x48,
     0x86, 0x02, 0x31, 0xe5, 0x62, 0x48, 0x06, 0xda, 0x62, 0x02, 0x31, 0xe6,
     0x72, 0x48, 0x06, 0xc0, 0x62, 0x0a, 0xc6, 0x65, 0x65, 0x05, 0x48, 0x04,
     0xa0, 0x48, 0x58, 0x58, 0x85, 0x0f, 0xf3, 0x7a, 0x83, 0x0e, 0xeb, 0x6b,
     0x63, 0x63, 0x6b, 0x0f, 0xcb, 0x6b, 0x63, 0x6b, 0x10, 0x45, 0x4d, 0x09,
     0x45, 0xa3, 0x42, 0x88, 0x0c, 0x48, 0x84, 0x0e, 0xf8, 0x72, 0x48, 0x0f,
     0xf2, 0x62, 0x50, 0x0d, 0xfa, 0x03, 0x63, 0x10, 0x47, 0x20, 0x45, 0xb0,
     0x11, 0x48, 0x88, 0x1b, 0x48, 0x13, 0xcf, 0x62, 0x06, 0x48, 0x50, 0x2f,
     0x48, 0x50, 0x26, 0x46, 0x2d, 0x89, 0x02, 0x33, 0xff, 0x25, 0x63, 0x6b,
     0x6c, 0x84, 0x02, 0x34, 0xed, 0x6a, 0x0b, 0x91, 0x0a, 0x2d, 0xef, 0x01,
     0x10, 0x63, 0x06, 0x42, 0x28, 0x8a, 0x01, 0x0b, 0x48, 0x88, 0x03, 0xdf,
     0x6a, 0x30, 0x48, 0x88, 0x01, 0x3b, 0xff, 0x08, 0x63, 0x88, 0x01, 0x3c,
     0xcf, 0x06, 0x63, 0x8a, 0x01, 0x3c, 0xdf, 0x08, 0x63, 0x88, 0x01, 0x3c,
     0xef, 0x08, 0x63, 0x88, 0x01, 0x3c, 0xff, 0x06, 0x63, 0x8b, 0x01, 0x3d,
     0xcf, 0x04, 0x6c, 0x87, 0x01, 0x3d, 0xdf, 0x08, 0x63, 0x98, 0x01, 0x3d,
     0xff, 0x08, 0x63, 0x88, 0x01, 0x3e, 0xcf, 0x08, 0x63, 0x88, 0x01, 0x3e,
     0xdf, 0x08, 0x63, 0x88, 0x01, 0x3e, 0xef, 0x63, 0x63, 0x01, 0x3d, 0xef,
     0x63, 0x63, 0x01, 0x3e, 0xf3, 0x62, 0x8b, 0x01, 0x3d, 0xf1, 0x04, 0x63,
     0x01, 0x3f, 0xc3, 0x62, 0x8b, 0x01, 0x3f, 0xcf, 0x63, 0x63, 0x01, 0x3d,
     0xf5, 0x63, 0x63, 0x8c, 0x01, 0x3f, 0xdf, 0x63, 0x63, 0x01, 0x3d, 0xf9,
     0x63, 0x63, 0x01, 0x3f, 0xe5, 0x62, 0x8b, 0x01, 0x3d, 0xf7, 0x63, 0x63,
     0x65, 0x63, 0x01, 0x3f, 0xf3, 0x62, 0x04, 0xa9, 0x0f, 0xc9, 0x7a, 0x01,
     0xeb, 0x62, 0x03, 0xe5, 0x62, 0x86, 0x02, 0x05, 0xce, 0x62, 0xad, 0x10,
     0x43, 0x93, 0x40, 0x0c, 0xb2, 0x1a, 0x44, 0x1c, 0xb0, 0x2f, 0x46, 0xb1,
     0x48, 0x09, 0xeb, 0x62, 0x01, 0x35, 0xfd, 0x62, 0x09, 0xfd, 0x72, 0x03,
     0x48, 0x09, 0xd1, 0x62, 0x09, 0xf1, 0x62, 0x09, 0xce, 0x64, 0x6c, 0x50,
     0x50, 0x86, 0x08, 0xfe, 0x63, 0x63, 0x32, 0x48, 0x87, 0x48, 0x48, 0x83,
     0x48, 0x07, 0x25, 0x8c, 0x17, 0x48, 0x92, 0x0e, 0x48, 0x02, 0x86, 0x06,
     0x48, 0x58, 0x1f, 0x48, 0x89, 0x48, 0x48, 0x01, 0x35, 0xf9, 0x62, 0x05,
     0x48, 0x83, 0x48, 0x09, 0xe5, 0x72, 0x48, 0x58, 0x0a, 0x48, 0x63, 0x09,
     0xd7, 0x67, 0x67, 0x09, 0xec, 0x72, 0x0a, 0xde, 0x62, 0x0a, 0xc7, 0x62,
     0x0a, 0xdd, 0x62, 0x0a, 0x2d, 0xd3, 0x62, 0x48, 0x48, 0x05, 0x1d, 0xa9,
     0x1a, 0x45, 0x13, 0x85, 0x10, 0x10, 0xe7, 0x28, 0x63, 0x21, 0x98, 0x10,
     0x32, 0xff, 0x33, 0x63, 0x2f, 0xad, 0x20, 0x45];

// When lower-casing characters we observe that the lower case version of a
// character is often a fixed distance from the upper case one.  The following
// array provides the distances that are common.  When upper-casing, the
// distances are negated.
const List<int> commonOffsets = const [1, 2, 8, 16, 26, 32, 48, 80];

// The bytecodes are designed to operate on a highly specialized three register
// machine.  The registers are X (eXtend) L (Left) and R (Right).  There are no
// branches or loops, and L can only increase, never decrease.  Apart from
// instructions that manipulate the internal machine state, there are two
// instructions, emitL and emitR, that declare a mapping from an original
// character to its mapped equivalent.
//
// The bytecodes are chosen from the observation that the mapping of a
// character is often close to the original character.  For this we use the
// emitL instruction).  For the cases where the mapped character is a long or
// uncommon distance from the original character, we have a second register, R,
// which can indicate the mapped character.  For this we use the emitR
// instruction.
//
// Since bytecodes have limited space for constant operands, we provide the
// extend instruction, which can provide high bits for later instructions.  It
// is also used to indicate repeat counts for EMITx instructions.
//
// Instructions/Bit pattern/Pseudocode
// extend:      00nnnnnn    X := (X << 6) + n;
// emitL:       010nnmmm    Repeat (X == 0 ? 1 : X) times:
//                            Emit(L, L + _fixedOffsets[m]);
//                            L += n+1;
//                            X = 0;
// emitR:       011nnmmm    Repeat (X == 0 ? 1 : X) times:
//                            R += m - bias;
//                            Emit(L, R);
//                            L += n+1;
//                            X = 0;
// addL         10nnnnnn    L += (X << 6) + n;
//                          X = 0;
// loadR        11nnnnnn    R = (X << 6) + n;
//                          X = 0;

const opcodeMask = 0xC0;
const extend = 0x00;
const emit = 0x40;
const addL = 0x80;
const loadR = 0xC0;

// Emit:
const postincrementShift = 3;
const postIncrementMask = 3;

const emitL = 0x40;
const emitR = 0x60;
const emitMask = 0xE0;
const emitRMask = 0x07;
const emitLMask = 0x07;
const emitRBias = 2;

// Other instructions:
const argumentBits = 6;
const argumentMask = 0x3f;

class Interpreter {
  List<int> _fixedOffsets = new List<int>();
  final List<int> _byteCodes;

  Interpreter(List<int> this._byteCodes, bool toUpper) {
    int sign = toUpper ? -1 : 1;
    for (int offset in commonOffsets) {
      _fixedOffsets.add(offset * sign);
    }
  }

  void interpret(bool map(int c, int mapped)) {
    int extendReg = 0;
    int leftReg = 0;
    int rightReg = 0;
    for (int byte in _byteCodes) {
      int opCode = byte & opcodeMask;
      int argument = (byte & argumentMask) + (extendReg << argumentBits);
      if (opCode == extend) {
        extendReg = argument;
      } else {
        if (opCode == emit) {
          if (extendReg == 0) extendReg = 1;
          int increment =
              ((byte >> postincrementShift) & postIncrementMask) + 1;
          for (int i = 0; i < extendReg; i++) {
            if ((byte & emitMask) == emitR) {
              int preIncrement = (byte & emitRMask) - emitRBias;
              rightReg += preIncrement;
              if (!map(leftReg, rightReg)) return;
            } else {
              // emitL.
              int offset = _fixedOffsets[byte & emitLMask];
              if (!map(leftReg, leftReg + offset)) return;
            }
            leftReg += increment;
          }
        } else {
          if (opCode == addL) {
            leftReg += argument;
          } else {
            // opCode == loadR.
            rightReg = argument;
          }
        }
        extendReg = 0;
      }
    }
  }
}
